/**
 * SMS Service - Africa's Talking Integration
 * Handles SMS sending and webhook processing for supplier communications
 * 
 * Configuration:
 * - Africa's Talking API for SMS delivery
 * - Webhook support for SMS replies
 * - Keyword recognition for automated processing
 * - Multi-language support (English, Swahili)
 */

import * as swahiliTemplates from './sms-templates/swahili.js';

const AFRICASTALKING_API_KEY = process.env.AFRICASTALKING_API_KEY;
const AFRICASTALKING_USERNAME = process.env.AFRICASTALKING_USERNAME;
const AFRICASTALKING_SENDER_ID = process.env.AFRICASTALKING_SENDER_ID || 'KISHEKA';
const SMS_ENABLED = process.env.SMS_ENABLED === 'true' || false;

/**
 * Send SMS via Africa's Talking
 * @param {Object} options - SMS options
 * @param {string} options.to - Recipient phone number (with country code, e.g., +254712345678)
 * @param {string} options.message - SMS message content
 * @returns {Promise<Object>} Send result with messageId
 */
export async function sendSMS({ to, message }) {
  if (!SMS_ENABLED) {
    console.log('SMS is disabled. Skipping SMS send.');
    return {
      success: false,
      error: 'SMS is disabled',
      skipped: true
    };
  }

  if (!AFRICASTALKING_API_KEY || !AFRICASTALKING_USERNAME) {
    console.error('Africa\'s Talking credentials not configured');
    throw new Error('Africa\'s Talking credentials not configured');
  }

  if (!to || !message) {
    throw new Error('Recipient phone number and message are required');
  }

  try {
    // Format phone number (ensure it starts with +)
    const formattedPhone = to.startsWith('+') ? to : `+${to}`;

    // const africasTalkingUrl = 'https://api.africastalking.com/version1/messaging';
    const africasTalkingUrl = 'https://api.sandbox.africastalking.com/version1/messaging';
    const response = await fetch(africasTalkingUrl, {
      method: 'POST',
      headers: {
        'ApiKey': AFRICASTALKING_API_KEY,
        'Content-Type': 'application/x-www-form-urlencoded',
        'Accept': 'application/json'
      },
      body: new URLSearchParams({
        username: AFRICASTALKING_USERNAME,
        to: formattedPhone,
        message: message,
        from: AFRICASTALKING_SENDER_ID
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Africa\'s Talking API error:', errorText);
      console.error('API Key (first 10 chars):', AFRICASTALKING_API_KEY?.substring(0, 10) + '...');
      console.error('Username:', AFRICASTALKING_USERNAME);
      console.error('Sender ID:', AFRICASTALKING_SENDER_ID);
      console.error('Response Status:', response.status, response.statusText);
      
      // Try to parse error response as JSON
      let errorDetails = errorText;
      try {
        const errorJson = JSON.parse(errorText);
        errorDetails = JSON.stringify(errorJson, null, 2);
      } catch (e) {
        // Not JSON, use as-is
      }
      
      throw new Error(`SMS send failed: ${response.status} ${response.statusText}. Details: ${errorDetails}`);
    }

    const data = await response.json();
    
    // Check response structure
    if (data.SMSMessageData?.Recipients?.[0]?.statusCode === 101) {
      return {
        success: true,
        messageId: data.SMSMessageData.Recipients[0].messageId,
        provider: 'africas_talking',
        status: data.SMSMessageData.Recipients[0].status
      };
    } else {
      const errorMessage = data.SMSMessageData?.Recipients?.[0]?.status || 'SMS send failed';
      console.error('SMS send error:', errorMessage);
      throw new Error(errorMessage);
    }
  } catch (error) {
    console.error('SMS send error:', error);
    throw error;
  }
}

/**
 * Send multiple SMS messages sequentially (for multi-part messages)
 * @param {Object} options - SMS options
 * @param {string} options.to - Recipient phone number
 * @param {Array<string>} options.messages - Array of message parts to send
 * @param {number} options.delayBetweenMessages - Delay in milliseconds between messages (default: 1000ms)
 * @returns {Promise<Object>} Send result with array of messageIds and success status
 */
export async function sendMultipleSMS({ to, messages, delayBetweenMessages = 1000 }) {
  if (!messages || !Array.isArray(messages) || messages.length === 0) {
    throw new Error('Messages array is required and must not be empty');
  }

  const results = {
    success: true,
    totalSent: 0,
    totalFailed: 0,
    messageIds: [],
    errors: []
  };

  // Send messages sequentially with delay to ensure proper ordering
  for (let i = 0; i < messages.length; i++) {
    try {
      // Add delay between messages (except for the first one)
      if (i > 0 && delayBetweenMessages > 0) {
        await new Promise(resolve => setTimeout(resolve, delayBetweenMessages));
      }

      const result = await sendSMS({ to, message: messages[i] });
      
      if (result.success && !result.skipped) {
        results.totalSent++;
        results.messageIds.push(result.messageId);
      } else if (result.skipped) {
        // SMS disabled - skip all
        results.messageIds.push(null);
      } else {
        results.totalFailed++;
        results.errors.push({
          part: i + 1,
          error: result.error || 'Unknown error'
        });
      }
    } catch (error) {
      results.totalFailed++;
      results.success = false;
      results.errors.push({
        part: i + 1,
        error: error.message || 'Failed to send SMS'
      });
      console.error(`[sendMultipleSMS] Failed to send part ${i + 1}:`, error);
    }
  }

  // If all messages failed, mark overall as failed
  if (results.totalSent === 0 && results.totalFailed > 0) {
    results.success = false;
  }

  return results;
}

/**
 * Split a long message into multiple parts that fit within SMS character limit
 * @param {string} message - Message to split
 * @param {number} maxLength - Maximum length per part (default: 160)
 * @param {string} partPrefix - Prefix for each part (e.g., "1/3: ")
 * @returns {Array<string>} Array of message parts
 */
export function splitMessage(message, maxLength = 160, partPrefix = '') {
  if (!message || typeof message !== 'string') {
    return [];
  }

  // If message fits in one part, return as-is
  if (message.length <= maxLength) {
    return partPrefix ? [`${partPrefix}${message}`] : [message];
  }

  const parts = [];
  const lines = message.split('\n');
  let currentPart = partPrefix;
  let currentLength = partPrefix.length;

  for (const line of lines) {
    const lineWithNewline = line + '\n';
    const lineLength = lineWithNewline.length;

    // If adding this line would exceed limit, start a new part
    if (currentLength + lineLength > maxLength && currentPart !== partPrefix) {
      // Remove trailing newline from current part
      parts.push(currentPart.trimEnd());
      currentPart = partPrefix;
      currentLength = partPrefix.length;
    }

    // If a single line is too long, split it
    if (lineLength > maxLength - currentLength) {
      // If current part has content, save it first
      if (currentPart !== partPrefix) {
        parts.push(currentPart.trimEnd());
        currentPart = partPrefix;
        currentLength = partPrefix.length;
      }

      // Split the long line by words
      const words = line.split(' ');
      for (const word of words) {
        const wordWithSpace = (currentPart === partPrefix ? '' : ' ') + word;
        if (currentLength + wordWithSpace.length > maxLength) {
          parts.push(currentPart.trimEnd());
          currentPart = partPrefix + word;
          currentLength = partPrefix.length + word.length;
        } else {
          currentPart += wordWithSpace;
          currentLength += wordWithSpace.length;
        }
      }
      currentPart += '\n';
      currentLength += 1;
    } else {
      currentPart += lineWithNewline;
      currentLength += lineLength;
    }
  }

  // Add the last part if it has content
  if (currentPart !== partPrefix) {
    parts.push(currentPart.trimEnd());
  }

  return parts;
}

/**
 * Calculate Levenshtein distance between two strings (for fuzzy matching)
 * @param {string} str1 - First string
 * @param {string} str2 - Second string
 * @returns {number} Edit distance
 */
function levenshteinDistance(str1, str2) {
  const len1 = str1.length;
  const len2 = str2.length;
  const matrix = Array(len2 + 1).fill(null).map(() => Array(len1 + 1).fill(null));

  for (let i = 0; i <= len1; i++) matrix[0][i] = i;
  for (let j = 0; j <= len2; j++) matrix[j][0] = j;

  for (let j = 1; j <= len2; j++) {
    for (let i = 1; i <= len1; i++) {
      const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
      matrix[j][i] = Math.min(
        matrix[j][i - 1] + 1,      // deletion
        matrix[j - 1][i] + 1,      // insertion
        matrix[j - 1][i - 1] + cost // substitution
      );
    }
  }

  return matrix[len2][len1];
}

/**
 * Calculate similarity score between two strings (0-1, where 1 is identical)
 * @param {string} str1 - First string
 * @param {string} str2 - Second string
 * @returns {number} Similarity score (0-1)
 */
function calculateSimilarity(str1, str2) {
  const maxLen = Math.max(str1.length, str2.length);
  if (maxLen === 0) return 1;
  const distance = levenshteinDistance(str1.toLowerCase(), str2.toLowerCase());
  return 1 - (distance / maxLen);
}

/**
 * Find best matching keyword using fuzzy matching
 * @param {string} text - Text to match
 * @param {Array<string>} keywords - Array of keywords to match against
 * @param {number} minSimilarity - Minimum similarity threshold (0-1, default 0.7)
 * @returns {Object|null} Best match with keyword and similarity score, or null if no match
 */
function findBestFuzzyMatch(text, keywords, minSimilarity = 0.7) {
  let bestMatch = null;
  let bestScore = 0;

  for (const keyword of keywords) {
    // Try exact match first (case-insensitive)
    if (text === keyword || text.includes(keyword) || keyword.includes(text)) {
      return { keyword, similarity: 1.0, matchType: 'exact' };
    }

    // Try fuzzy match
    const similarity = calculateSimilarity(text, keyword);
    if (similarity >= minSimilarity && similarity > bestScore) {
      bestScore = similarity;
      bestMatch = { keyword, similarity, matchType: 'fuzzy' };
    }
  }

  return bestMatch;
}

/**
 * Parse SMS reply for purchase order confirmation
 * Extracts action (accept/reject/modify), purchase order number, rejection reasons, modification details, and partial responses from SMS text
 * Enhanced with fuzzy matching for typos and natural language patterns
 * @param {string} smsText - SMS message text
 * @returns {Object} Parsed result with action, PO number, rejection reason, modification details, and partial response data
 */
export function parseSMSReply(smsText) {
  if (!smsText || typeof smsText !== 'string') {
    return { 
      action: null, 
      purchaseOrderNumber: null,
      rejectionReason: null,
      rejectionSubcategory: null,
      modificationDetails: null,
      isPartialResponse: false,
      materialResponses: null,
      confidence: 0
    };
  }

  // Remove emojis and special characters that might interfere
  const cleanedText = smsText.replace(/[\u{1F300}-\u{1F9FF}]/gu, '').trim();
  const text = cleanedText.toUpperCase().trim();
  
  // Keywords for actions (with common typos)
  const acceptKeywords = ['ACCEPT', 'ACEPT', 'ACEPPT', 'ACCEPTED', 'YES', 'OK', 'OKAY', 'CONFIRM', 'CONFIRMED', 'APPROVE', 'APPROVED', 'Y', '1'];
  const rejectKeywords = ['REJECT', 'REJCT', 'REJECTED', 'NO', 'DECLINE', 'DECLINED', 'CANCEL', 'CANCELLED', 'REFUSE', 'REFUSED', 'N', '2'];
  const modifyKeywords = ['MODIFY', 'MODFY', 'CHANGE', 'CHANGED', 'UPDATE', 'UPDATED', 'EDIT', 'EDITED', 'ADJUST', 'ADJUSTED', '3'];
  
  // Swahili keywords for actions
  const swahiliAcceptKeywords = ['KUBALI', 'KUBALIA', 'KUBALIWA', 'NDIO', 'SAWA', 'THIBITISHA', 'THIBITI'];
  const swahiliRejectKeywords = ['KATA', 'KATAA', 'KATALIWA', 'LA', 'SIO', 'SITAKI'];
  const swahiliModifyKeywords = ['BADILISHA', 'BADILI', 'GEUZA', 'REKEBISHA'];
  
  // Combined keyword lists (English + Swahili)
  const allAcceptKeywords = [...acceptKeywords, ...swahiliAcceptKeywords];
  const allRejectKeywords = [...rejectKeywords, ...swahiliRejectKeywords];
  const allModifyKeywords = [...modifyKeywords, ...swahiliModifyKeywords];

  // Extract purchase order number (format: PO-YYYYMMDD-001 or PO-001)
  const poMatch = text.match(/PO[-\s]?(\d{8}-\d{3}|\d{3})/i);
  const purchaseOrderNumber = poMatch ? poMatch[0].replace(/[-\s]/g, '-') : null;
  
  // Check for numeric short codes (1 = accept, 2 = reject, 3 = modify)
  // These can be standalone or with PO number
  const numericShortCodeMatch = text.match(/^(\d+)$/); // Just a number
  if (numericShortCodeMatch && !purchaseOrderNumber) {
    const code = parseInt(numericShortCodeMatch[1]);
    if (code === 1) {
      return {
        action: 'accept',
        purchaseOrderNumber: null, // Will be matched by phone number
        rejectionReason: null,
        rejectionSubcategory: null,
        modificationDetails: null,
        isPartialResponse: false,
        materialResponses: null,
        confidence: 0.95,
        originalText: smsText,
        isShortCode: true
      };
    } else if (code === 2) {
      return {
        action: 'reject',
        purchaseOrderNumber: null,
        rejectionReason: null,
        rejectionSubcategory: null,
        modificationDetails: null,
        isPartialResponse: false,
        materialResponses: null,
        confidence: 0.95,
        originalText: smsText,
        isShortCode: true
      };
    } else if (code === 3) {
      return {
        action: 'modify',
        purchaseOrderNumber: null,
        rejectionReason: null,
        rejectionSubcategory: null,
        modificationDetails: null,
        isPartialResponse: false,
        materialResponses: null,
        confidence: 0.95,
        originalText: smsText,
        isShortCode: true
      };
    }
  }
  
  // Check for single character short codes (Y/N) or very short responses
  const singleCharMatch = text.match(/^([YN123])$/i);
  if (singleCharMatch && !purchaseOrderNumber) {
    const char = singleCharMatch[1].toUpperCase();
    if (char === 'Y' || char === '1') {
      return {
        action: 'accept',
        purchaseOrderNumber: null,
        rejectionReason: null,
        rejectionSubcategory: null,
        modificationDetails: null,
        isPartialResponse: false,
        materialResponses: null,
        confidence: 0.95,
        originalText: smsText,
        isShortCode: true
      };
    } else if (char === 'N' || char === '2') {
      return {
        action: 'reject',
        purchaseOrderNumber: null,
        rejectionReason: null,
        rejectionSubcategory: null,
        modificationDetails: null,
        isPartialResponse: false,
        materialResponses: null,
        confidence: 0.95,
        originalText: smsText,
        isShortCode: true
      };
    }
  }

  // Check for partial response pattern: "ACCEPT 1,3,5 REJECT 2,4" or "ACCEPT ALL"
  let isPartialResponse = false;
  let materialResponses = null;
  let action = null; // Declare action once
  let confidence = 0.5; // Default confidence
  
  // Pattern: ACCEPT ALL or REJECT ALL (including Swahili)
  const allMatch = text.match(/(ACCEPT|REJECT|ACEPT|REJCT|KUBALI|KATA)\s+ALL|ZOTE/i);
  
  // Pattern: ACCEPT 1,3,5 REJECT 2,4 (with numbers) - includes Swahili keywords
  const partialPattern = /(ACCEPT|REJECT|ACEPT|REJCT|MODIFY|MODFY|KUBALI|KATA|BADILISHA)\s+(\d+(?:[,\s]+\d+)*|ALL|ZOTE)/gi;
  const partialMatches = [...text.matchAll(partialPattern)];
  
  if (partialMatches.length > 0 || allMatch) {
    isPartialResponse = true;
    materialResponses = [];
    
    // Handle "ACCEPT ALL" or "REJECT ALL" or "KUBALI ZOTE" or "KATA ZOTE"
    if (allMatch) {
      const allAction = allMatch[1].toUpperCase();
      if (allAcceptKeywords.some(k => allAction.includes(k))) {
        materialResponses.push({ action: 'accept', materials: 'all' });
        action = 'accept';
        confidence = 0.95;
      } else if (allRejectKeywords.some(k => allAction.includes(k))) {
        materialResponses.push({ action: 'reject', materials: 'all' });
        action = 'reject';
        confidence = 0.95;
      }
    } else {
      // Handle numbered responses: "ACCEPT 1,3,5 REJECT 2,4" or "KUBALI 1,3,5 KATA 2,4"
      for (const match of partialMatches) {
        const actionWord = match[1].toUpperCase();
        const materialsStr = match[2].toUpperCase();
        
        let materialAction = null;
        if (allAcceptKeywords.some(k => actionWord.includes(k))) {
          materialAction = 'accept';
        } else if (allRejectKeywords.some(k => actionWord.includes(k))) {
          materialAction = 'reject';
        } else if (allModifyKeywords.some(k => actionWord.includes(k))) {
          materialAction = 'modify';
        }
        
        if (materialAction && materialsStr !== 'ALL' && materialsStr !== 'ZOTE') {
          // Extract numbers from string like "1,3,5" or "1 3 5"
          const numbers = materialsStr.split(/[,\s]+/).map(n => parseInt(n.trim())).filter(n => !isNaN(n) && n > 0);
          if (numbers.length > 0) {
            materialResponses.push({ action: materialAction, materials: numbers });
          }
        }
      }
      
      // If we have partial responses, determine overall action
      if (materialResponses.length > 0) {
        const hasAccept = materialResponses.some(mr => mr.action === 'accept');
        const hasReject = materialResponses.some(mr => mr.action === 'reject');
        const hasModify = materialResponses.some(mr => mr.action === 'modify');
        
        // Determine overall action based on partial responses
        if (hasModify || (hasAccept && hasReject)) {
          action = 'modify'; // Mixed responses = modify
          confidence = 0.9;
        } else if (hasAccept && !hasReject) {
          action = 'accept';
          confidence = 0.9;
        } else if (hasReject && !hasAccept) {
          action = 'reject';
          confidence = 0.9;
        }
      }
    }
  }

  // Determine action with priority (accept > reject > modify) if not already set by partial response
  if (!action) {
    // Check for negation words that might reverse the action
    const negationWords = ['NOT', "DON'T", "WON'T", 'NEVER', 'CANT', "CAN'T", 'SIO', 'HAWEZI'];
    const hasNegation = negationWords.some(word => text.includes(word));
    
    // Check for short code responses (just the keyword without PO number)
    // This allows responses like "ACCEPT" or "KUBALI" without PO number
    const isShortCodeResponse = !purchaseOrderNumber && (
      allAcceptKeywords.some(k => text === k || text.startsWith(k + ' ') || text.endsWith(' ' + k)) ||
      allRejectKeywords.some(k => text === k || text.startsWith(k + ' ') || text.endsWith(' ' + k)) ||
      allModifyKeywords.some(k => text === k || text.startsWith(k + ' ') || text.endsWith(' ' + k))
    );
    
    // Natural language patterns for common responses
    const naturalLanguagePatterns = {
      accept: [
        /(?:i|we|i'll|we'll)\s+(?:can|will|agree|accept|confirm|approve)/i,
        /(?:sure|fine|okay|ok|yes|yeah|yep|alright|alrighty)/i,
        /(?:i|we)\s+(?:accept|agree|confirm|approve)/i,
        /(?:that|this)\s+(?:is|sounds)\s+(?:fine|ok|okay|good|acceptable)/i,
        /(?:go|proceed|continue)\s+(?:ahead|with|on)/i,
        /(?:no\s+)?problem/i,
        /(?:sounds?\s+)?good/i
      ],
      reject: [
        /(?:i|we|i'll|we'll)\s+(?:cannot|cant|can't|unable|wont|won't|will not)\s+(?:do|accept|provide|deliver|supply)/i,
        /(?:sorry|unfortunately|regretfully)\s+(?:i|we|but)/i,
        /(?:i|we)\s+(?:decline|reject|refuse|cannot|cant|can't)/i,
        /(?:not\s+)?(?:possible|available|feasible|doable)/i,
        /(?:too\s+)?(?:expensive|high|much|difficult|hard)/i,
        /(?:cannot|cant|can't)\s+(?:meet|fulfill|provide|deliver)/i
      ],
      modify: [
        /(?:i|we)\s+(?:need|want|require|request|suggest|propose)\s+(?:to\s+)?(?:change|modify|adjust|update)/i,
        /(?:can|could)\s+(?:we|you)\s+(?:change|modify|adjust|update)/i,
        /(?:instead|alternatively|rather|prefer)/i,
        /(?:different|alternative|other)\s+(?:price|quantity|date|delivery|spec)/i,
        /(?:what\s+about|how\s+about)\s+(?:instead|if)/i
      ]
    };
    
    // Try exact keyword matching first
    let matchedAction = null;
    let matchConfidence = 0;
    let matchType = 'none';
    
    // Check exact keyword matches
    if (allAcceptKeywords.some(keyword => {
      const regex = new RegExp(`\\b${keyword}\\b`, 'i');
      return regex.test(text);
    })) {
      matchedAction = 'accept';
      matchConfidence = isShortCodeResponse ? 0.95 : 0.9;
      matchType = 'exact';
    } else if (allRejectKeywords.some(keyword => {
      const regex = new RegExp(`\\b${keyword}\\b`, 'i');
      return regex.test(text);
    })) {
      matchedAction = 'reject';
      matchConfidence = isShortCodeResponse ? 0.95 : 0.9;
      matchType = 'exact';
    } else if (allModifyKeywords.some(keyword => {
      const regex = new RegExp(`\\b${keyword}\\b`, 'i');
      return regex.test(text);
    })) {
      matchedAction = 'modify';
      matchConfidence = isShortCodeResponse ? 0.9 : 0.85;
      matchType = 'exact';
    }
    
    // If no exact match, try natural language patterns
    if (!matchedAction) {
      for (const [actionType, patterns] of Object.entries(naturalLanguagePatterns)) {
        for (const pattern of patterns) {
          if (pattern.test(text)) {
            matchedAction = actionType;
            matchConfidence = 0.75; // Lower confidence for natural language
            matchType = 'natural';
            break;
          }
        }
        if (matchedAction) break;
      }
    }
    
    // If still no match, try fuzzy matching on individual words
    if (!matchedAction) {
      const words = text.split(/\s+/).filter(w => w.length > 2); // Filter short words
      for (const word of words) {
        // Try accept keywords
        const acceptMatch = findBestFuzzyMatch(word, allAcceptKeywords, 0.7);
        if (acceptMatch && acceptMatch.similarity > matchConfidence) {
          matchedAction = 'accept';
          matchConfidence = acceptMatch.similarity * 0.85; // Slightly lower for fuzzy
          matchType = 'fuzzy';
        }
        
        // Try reject keywords
        const rejectMatch = findBestFuzzyMatch(word, allRejectKeywords, 0.7);
        if (rejectMatch && rejectMatch.similarity > matchConfidence) {
          matchedAction = 'reject';
          matchConfidence = rejectMatch.similarity * 0.85;
          matchType = 'fuzzy';
        }
        
        // Try modify keywords
        const modifyMatch = findBestFuzzyMatch(word, allModifyKeywords, 0.7);
        if (modifyMatch && modifyMatch.similarity > matchConfidence) {
          matchedAction = 'modify';
          matchConfidence = modifyMatch.similarity * 0.8; // Lower for modify
          matchType = 'fuzzy';
        }
      }
    }
    
    // Apply matched action if found
    if (matchedAction) {
      // Handle negation
      if (hasNegation) {
        if (matchedAction === 'accept' && (text.indexOf('NOT') < text.indexOf('ACCEPT') || text.indexOf('NOT') < text.indexOf('KUBALI'))) {
          action = 'reject';
          confidence = Math.max(0.6, matchConfidence - 0.1);
        } else if (matchedAction === 'reject' && (text.indexOf('NOT') < text.indexOf('REJECT') || text.indexOf('NOT') < text.indexOf('KATA'))) {
          action = 'accept';
          confidence = Math.max(0.6, matchConfidence - 0.1);
        } else {
          action = matchedAction;
          confidence = matchConfidence;
        }
      } else {
        action = matchedAction;
        confidence = matchConfidence;
      }
    }
  }

  // Extract rejection reason from text
  let rejectionReason = null;
  let rejectionSubcategory = null;
  let rejectionConfidence = 0;
  
  if (action === 'reject') {
    const rejectionPatterns = {
      // Price-related
      price_too_high: {
        keywords: ['PRICE', 'COST', 'EXPENSIVE', 'TOO HIGH', 'TOO MUCH', 'CHEAPER', 'LOWER PRICE', 'BUDGET'],
        subcategories: {
          market_rates_higher: ['MARKET', 'RATES'],
          material_costs_increased: ['MATERIAL COST', 'RAW MATERIAL'],
          labor_costs_high: ['LABOR', 'WORKER', 'MANPOWER'],
          overhead_costs: ['OVERHEAD', 'OPERATIONAL'],
          insufficient_profit_margin: ['PROFIT', 'MARGIN'],
          currency_fluctuation: ['CURRENCY', 'EXCHANGE', 'RATE']
        }
      },
      // Availability
      unavailable: {
        keywords: ['UNAVAILABLE', 'OUT OF STOCK', 'NO STOCK', 'NOT AVAILABLE', 'DONT HAVE', "DON'T HAVE", 'CANT GET', "CAN'T GET", 'DISCONTINUED'],
        subcategories: {
          out_of_stock: ['OUT OF STOCK', 'NO STOCK', 'STOCK'],
          material_discontinued: ['DISCONTINUED', 'NO LONGER'],
          seasonal_unavailable: ['SEASONAL', 'SEASON'],
          supplier_shortage: ['SHORTAGE', 'SHORT'],
          manufacturing_delay: ['MANUFACTURING', 'PRODUCTION', 'DELAY'],
          shipping_constraints: ['SHIPPING', 'TRANSPORT', 'LOGISTICS']
        }
      },
      // Timeline
      timeline: {
        keywords: ['TIME', 'DELIVERY', 'DEADLINE', 'TOO SOON', 'TOO FAST', 'LATE', 'DELAY', 'SCHEDULE', 'RUSH'],
        subcategories: {
          delivery_date_too_soon: ['TOO SOON', 'TOO FAST', 'RUSH', 'URGENT'],
          insufficient_production_time: ['PRODUCTION TIME', 'MAKE TIME'],
          logistics_delay: ['LOGISTICS', 'TRANSPORT', 'SHIPPING'],
          weather_related_delays: ['WEATHER', 'RAIN', 'STORM'],
          current_workload_too_high: ['WORKLOAD', 'BUSY', 'FULL'],
          staff_shortage: ['STAFF', 'WORKER', 'MANPOWER']
        }
      },
      // Specifications
      specifications: {
        keywords: ['SPECIFICATION', 'SPEC', 'QUALITY', 'STANDARD', 'GRADE', 'CERTIFICATION', 'TESTING', 'REQUIREMENT'],
        subcategories: {
          cannot_meet_quality_standards: ['QUALITY', 'STANDARD'],
          technical_specifications_unmet: ['TECHNICAL', 'SPEC'],
          material_grade_unavailable: ['GRADE', 'TYPE'],
          custom_requirements_impossible: ['CUSTOM', 'SPECIAL'],
          certification_requirements: ['CERTIFICATION', 'CERTIFIED'],
          testing_requirements: ['TESTING', 'TEST']
        }
      },
      // Quantity
      quantity: {
        keywords: ['QUANTITY', 'QTY', 'AMOUNT', 'TOO MUCH', 'TOO MANY', 'MINIMUM', 'MAXIMUM', 'CAPACITY'],
        subcategories: {
          below_minimum_order_quantity: ['MINIMUM', 'MIN'],
          exceeds_production_capacity: ['CAPACITY', 'MAXIMUM', 'MAX'],
          batch_size_constraints: ['BATCH', 'BULK'],
          storage_limitations: ['STORAGE', 'SPACE'],
          can_only_partial_fulfill: ['PARTIAL', 'SOME', 'ONLY']
        }
      },
      // Business policy
      business_policy: {
        keywords: ['POLICY', 'TERM', 'CONTRACT', 'PAYMENT', 'INSURANCE', 'LICENSE', 'GEOGRAPHIC'],
        subcategories: {
          unacceptable_payment_terms: ['PAYMENT', 'TERM'],
          contract_terms_unacceptable: ['CONTRACT', 'AGREEMENT'],
          insurance_requirements: ['INSURANCE'],
          licensing_restrictions: ['LICENSE', 'PERMIT'],
          geographic_service_limits: ['GEOGRAPHIC', 'AREA', 'LOCATION'],
          client_specific_restrictions: ['CLIENT', 'CUSTOMER']
        }
      },
      // External factors
      external_factors: {
        keywords: ['REGULATORY', 'MARKET', 'FORCE MAJEURE', 'TRANSPORTATION', 'SUPPLY CHAIN', 'ECONOMIC'],
        subcategories: {
          regulatory_changes: ['REGULATORY', 'REGULATION'],
          market_volatility: ['MARKET', 'VOLATILITY'],
          force_majeure: ['FORCE MAJEURE', 'DISASTER'],
          transportation_issues: ['TRANSPORTATION', 'TRANSPORT'],
          supply_chain_disruption: ['SUPPLY CHAIN', 'CHAIN'],
          economic_conditions: ['ECONOMIC', 'ECONOMY']
        }
      }
    };

    // Find matching rejection reason
    for (const [reasonId, pattern] of Object.entries(rejectionPatterns)) {
      const mainMatch = pattern.keywords.some(keyword => text.includes(keyword));
      if (mainMatch) {
        rejectionReason = reasonId;
        rejectionConfidence = 0.7;
        
        // Try to find subcategory
        for (const [subcatKey, subcatKeywords] of Object.entries(pattern.subcategories)) {
          if (subcatKeywords.some(keyword => text.includes(keyword))) {
            rejectionSubcategory = pattern.subcategories[subcatKey];
            rejectionConfidence = 0.85;
            break;
          }
        }
        break;
      }
    }

    // If no specific reason found, default to 'other'
    if (!rejectionReason) {
      rejectionReason = 'other';
      rejectionSubcategory = 'not_specified';
      rejectionConfidence = 0.3;
    }
  }

  // Extract modification details
  let modificationDetails = null;
  if (action === 'modify') {
    modificationDetails = {
      unitCost: null,
      quantityOrdered: null,
      deliveryDate: null,
      notes: null
    };

    // Extract price/cost modifications
    const priceMatch = text.match(/(?:PRICE|COST|UNIT)[\s:]*KES?[\s:]*(\d+(?:[.,]\d+)?)/i);
    if (priceMatch) {
      modificationDetails.unitCost = parseFloat(priceMatch[1].replace(/,/g, ''));
    }

    // Extract quantity modifications
    const qtyMatch = text.match(/(?:QTY|QUANTITY|QTY)[\s:]*(\d+(?:[.,]\d+)?)/i);
    if (qtyMatch) {
      modificationDetails.quantityOrdered = parseFloat(qtyMatch[1].replace(/,/g, ''));
    }

    // Extract date modifications (various formats)
    const dateFormats = [
      /(\d{1,2})[-\/](\d{1,2})[-\/](\d{2,4})/, // DD-MM-YYYY or DD/MM/YYYY
      /(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})/, // YYYY-MM-DD or YYYY/MM/DD
      /(?:DATE|DELIVERY)[\s:]*(\d{1,2})[-\/](\d{1,2})[-\/](\d{2,4})/i
    ];
    
    for (const dateFormat of dateFormats) {
      const dateMatch = text.match(dateFormat);
      if (dateMatch) {
        try {
          let year, month, day;
          if (dateMatch[0].length > 8) {
            // YYYY-MM-DD format
            year = parseInt(dateMatch[1]);
            month = parseInt(dateMatch[2]) - 1;
            day = parseInt(dateMatch[3]);
          } else {
            // DD-MM-YYYY format
            day = parseInt(dateMatch[1]);
            month = parseInt(dateMatch[2]) - 1;
            year = parseInt(dateMatch[3]);
            if (year < 100) year += 2000; // Assume 2000s for 2-digit years
          }
          const date = new Date(year, month, day);
          if (!isNaN(date.getTime())) {
            modificationDetails.deliveryDate = date.toISOString().split('T')[0];
          }
        } catch (e) {
          // Invalid date, skip
        }
        break;
      }
    }

    // Extract notes (everything after MODIFY keyword)
    const modifyIndex = text.indexOf('MODIFY');
    if (modifyIndex !== -1) {
      const notesText = cleanedText.substring(smsText.toUpperCase().indexOf('MODIFY') + 6).trim();
      if (notesText && notesText.length > 0) {
        modificationDetails.notes = notesText.substring(0, 500); // Limit to 500 chars
      }
    }
  }

  return {
    action,
    purchaseOrderNumber,
    rejectionReason,
    rejectionSubcategory,
    modificationDetails,
    isPartialResponse,
    materialResponses,
    isShortCode: !purchaseOrderNumber && action !== null, // Mark as short code if no PO number but action detected
    confidence: action === 'reject' ? rejectionConfidence : confidence,
    originalText: smsText
  };
}

/**
 * Get supplier language preference
 * @param {Object} supplier - Supplier object
 * @returns {string} Language code ('sw' for Swahili, 'en' for English, default 'en')
 */
export function getSupplierLanguage(supplier) {
  if (!supplier) return 'en';
  
  // Check for language preference (can be 'en', 'sw', 'both')
  const languagePreference = supplier.languagePreference || supplier.preferredLanguage || 'en';
  
  // If 'both', default to English for now (can be enhanced to alternate)
  if (languagePreference === 'both') return 'en';
  
  return languagePreference === 'sw' ? 'sw' : 'en';
}

/**
 * Generate SMS message for purchase order (with language support and personalization)
 * @param {Object} options - Purchase order details
 * @param {string} options.purchaseOrderNumber - PO number
 * @param {string} options.materialName - Material name
 * @param {number} options.quantity - Quantity ordered
 * @param {string} options.unit - Unit of measurement
 * @param {number} options.totalCost - Total cost
 * @param {string} options.shortLink - Short URL for full details
 * @param {Date} options.deliveryDate - Delivery date (optional)
 * @param {number} options.unitCost - Unit cost (optional)
 * @param {string} options.language - Language code ('en' or 'sw'), defaults to 'en'
 * @param {Object} options.supplier - Supplier object (for auto language detection)
 * @param {string} options.projectId - Project ID for personalization (optional)
 * @param {Object} options.relationshipContext - Pre-fetched relationship context (optional)
 * @param {boolean} options.enablePersonalization - Enable personalization (default: true)
 * @returns {Promise<string>|string} Formatted SMS message (async if personalization enabled)
 */
export async function generatePurchaseOrderSMS({ purchaseOrderNumber, materialName, quantity, unit, totalCost, shortLink, deliveryDate = null, unitCost = null, language = null, supplier = null, projectId = null, relationshipContext = null, enablePersonalization = true }) {
  // Auto-detect language from supplier if not provided
  if (!language && supplier) {
    language = getSupplierLanguage(supplier);
  }
  
  // Default to English if not specified
  language = language || 'en';
  
  // Get relationship context if personalization enabled
  let context = relationshipContext;
  if (enablePersonalization && supplier && !context) {
    const { getSupplierRelationshipContext } = await import('./sms-personalization.js');
    context = await getSupplierRelationshipContext(supplier, projectId);
  }
  
  // Use Swahili template if requested
  if (language === 'sw') {
    const baseMessage = swahiliTemplates.generatePurchaseOrderSMSSwahili({
      purchaseOrderNumber,
      materialName,
      quantity,
      unit,
      totalCost,
      shortLink,
      deliveryDate,
      unitCost
    });
    
    // Apply personalization if enabled
    if (enablePersonalization && context) {
      const { personalizeMessage } = await import('./sms-personalization.js');
      return personalizeMessage(baseMessage, context, language, {
        includeGreeting: true,
        includeRelationship: context.totalOrders > 3, // Only for established relationships
        includeProject: !!projectId
      });
    }
    
    return baseMessage;
  }
  
  // Default English implementation
  // Check if order is urgent (delivery today or tomorrow)
  const deliveryDateObj = deliveryDate ? new Date(deliveryDate) : null;
  let isUrgent = false;
  
  if (deliveryDateObj) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const deliveryDateOnly = new Date(deliveryDateObj);
    deliveryDateOnly.setHours(0, 0, 0, 0);
    
    const daysUntilDelivery = Math.ceil((deliveryDateOnly - today) / (1000 * 60 * 60 * 24));
    isUrgent = daysUntilDelivery <= 1; // Urgent if delivery is today or tomorrow
  }
  
  // Format delivery date if provided
  const deliveryDateStr = deliveryDate 
    ? new Date(deliveryDate).toLocaleDateString('en-KE', { month: 'short', day: 'numeric' })
    : null;
  
  // Use urgent formatting if order is urgent
  if (isUrgent) {
    const dateStr = deliveryDateObj && deliveryDateOnly.getTime() === today.getTime()
      ? 'TODAY'
      : 'TOMORROW';
    
    let message = `ðŸš¨ URGENT PO: ${purchaseOrderNumber}\nMaterial: ${materialName}\nQty: ${quantity} ${unit}`;
    
    if (unitCost !== null && unitCost > 0) {
      message += `\nUnit: KES ${unitCost.toLocaleString()}`;
    }
    
    message += `\nTotal: KES ${totalCost.toLocaleString()}`;
    message += `\nDelivery: ${dateStr}`;
    message += `\nPlease respond IMMEDIATELY\nReply: ACCEPT/REJECT or 1/2\nDetails: ${shortLink || 'Contact us'}`;
    
    // Apply personalization if enabled
    if (enablePersonalization && context) {
      const { personalizeMessage } = await import('./sms-personalization.js');
      return personalizeMessage(message, context, language, {
        includeGreeting: true,
        includeRelationship: context.totalOrders > 3,
        includeProject: !!projectId
      });
    }
    
    return message;
  }
  
  // Build message with delivery date if available
  let message = `New PO: ${purchaseOrderNumber}\nMaterial: ${materialName}\nQty: ${quantity} ${unit}`;
  
  if (unitCost !== null && unitCost > 0) {
    message += `\nUnit: KES ${unitCost.toLocaleString()}`;
  }
  
  message += `\nTotal: KES ${totalCost.toLocaleString()}`;
  
  if (deliveryDateStr) {
    message += `\nDelivery: ${deliveryDateStr}`;
  }
  
  // Add short code instructions
  message += `\nReply: ACCEPT/REJECT or 1/2\nDetails: ${shortLink || 'Contact us'}`;
  
  // If message is too long, truncate material name
  if (message.length > 160) {
    const baseLength = message.length - materialName.length;
    const maxMaterialLength = Math.max(10, 160 - baseLength - 10);
    const truncatedMaterial = materialName.length > maxMaterialLength 
      ? materialName.substring(0, maxMaterialLength) + '...'
      : materialName;
    
    // Rebuild message with truncated material
    message = `New PO: ${purchaseOrderNumber}\nMaterial: ${truncatedMaterial}\nQty: ${quantity} ${unit}`;
    
    if (unitCost !== null && unitCost > 0) {
      message += `\nUnit: KES ${unitCost.toLocaleString()}`;
    }
    
    message += `\nTotal: KES ${totalCost.toLocaleString()}`;
    
    if (deliveryDateStr) {
      message += `\nDelivery: ${deliveryDateStr}`;
    }
    
    message += `\nReply: ACCEPT/REJECT or 1/2\nDetails: ${shortLink || 'Contact us'}`;
  }
  
  // Apply personalization if enabled
  if (enablePersonalization && context) {
    const { personalizeMessage } = await import('./sms-personalization.js');
    return personalizeMessage(message, context, language, {
      includeGreeting: true,
      includeRelationship: context.totalOrders > 3, // Only for established relationships
      includeProject: !!projectId
    });
  }
  
  return message;
}

/**
 * Generate SMS message(s) for bulk purchase order with detailed material information
 * Returns single message for 1-4 materials, or multiple messages for 5+ materials
 * @param {Object} options - Purchase order details
 * @param {string} options.purchaseOrderNumber - PO number
 * @param {Array<Object>} options.materials - Array of material objects with materialName, quantity, unit, unitCost, totalCost
 * @param {number} options.totalCost - Total cost for all materials
 * @param {string} options.shortLink - Short URL for full details
 * @param {Date} options.deliveryDate - Delivery date (optional)
 * @param {boolean} options.enableMultiPart - Whether to use multi-part SMS for 5+ materials (default: true)
 * @param {string} options.language - Language code ('en' or 'sw'), defaults to 'en'
 * @param {Object} options.supplier - Supplier object (for auto language detection)
 * @param {string} options.projectId - Project ID for personalization (optional)
 * @param {Object} options.relationshipContext - Pre-fetched relationship context (optional)
 * @param {boolean} options.enablePersonalization - Enable personalization (default: true)
 * @returns {Promise<string|Array<string>>|string|Array<string>} Single message string or array of message parts for multi-part SMS (async if personalization enabled)
 */
export async function generateBulkPurchaseOrderSMS({ purchaseOrderNumber, materials, totalCost, shortLink, deliveryDate = null, enableMultiPart = true, language = null, supplier = null, projectId = null, relationshipContext = null, enablePersonalization = true }) {
  // Auto-detect language from supplier if not provided
  if (!language && supplier) {
    language = getSupplierLanguage(supplier);
  }
  
  // Default to English if not specified
  language = language || 'en';
  
  // Get relationship context if personalization enabled
  let context = relationshipContext;
  if (enablePersonalization && supplier && !context) {
    const { getSupplierRelationshipContext } = await import('./sms-personalization.js');
    context = await getSupplierRelationshipContext(supplier, projectId);
  }
  
  // Use Swahili template if requested
  if (language === 'sw') {
    const baseMessage = swahiliTemplates.generateBulkPurchaseOrderSMSSwahili({
      purchaseOrderNumber,
      materials,
      totalCost,
      shortLink,
      deliveryDate,
      enableMultiPart
    });
    
    // Apply personalization if enabled (only to first message if multi-part)
    if (enablePersonalization && context) {
      const { personalizeMessage } = await import('./sms-personalization.js');
      if (Array.isArray(baseMessage)) {
        // Multi-part: personalize first message only
        const personalized = personalizeMessage(baseMessage[0], context, language, {
          includeGreeting: true,
          includeRelationship: context.totalOrders > 3,
          includeProject: !!projectId
        });
        return [personalized, ...baseMessage.slice(1)];
      } else {
        return personalizeMessage(baseMessage, context, language, {
          includeGreeting: true,
          includeRelationship: context.totalOrders > 3,
          includeProject: !!projectId
        });
      }
    }
    
    return baseMessage;
  }
  
  // Default English implementation
  if (!materials || !Array.isArray(materials) || materials.length === 0) {
    // Fallback to generic message if no materials
    return generatePurchaseOrderSMS({
      purchaseOrderNumber,
      materialName: 'Multiple materials',
      quantity: 0,
      unit: 'items',
      totalCost,
      shortLink,
      deliveryDate
    });
  }

  // Format delivery date if provided
  const deliveryDateStr = deliveryDate 
    ? new Date(deliveryDate).toLocaleDateString('en-KE', { month: 'short', day: 'numeric' })
    : null;

  // Helper function to truncate material name if too long
  const truncateName = (name, maxLength = 20) => {
    if (name.length <= maxLength) return name;
    return name.substring(0, maxLength - 3) + '...';
  };

  // Helper function to format material line
  const formatMaterialLine = (material, index, showCost = false) => {
    const name = truncateName(material.materialName || material.name || `Material ${index + 1}`, 18);
    const qty = material.quantity || material.quantityNeeded || 0;
    const unit = material.unit || '';
    const cost = showCost && material.unitCost ? ` @ KES ${material.unitCost.toLocaleString()}` : '';
    return `${index + 1}. ${name}: ${qty} ${unit}${cost}`;
  };

  const materialCount = materials.length;

  // Strategy 1: 1-2 materials - Show full details with costs (single message)
  if (materialCount <= 2) {
    let message = `New PO: ${purchaseOrderNumber}\n`;
    
    materials.forEach((material, index) => {
      message += formatMaterialLine(material, index, true) + '\n';
    });
    
    message += `Total: KES ${totalCost.toLocaleString()}`;
    
    if (deliveryDateStr) {
      message += `\nDelivery: ${deliveryDateStr}`;
    }
    
    message += `\nReply: ACCEPT/REJECT or 1/2\nDetails: ${shortLink || 'Contact us'}`;

    // If message is too long, remove costs
    if (message.length > 160) {
      message = `New PO: ${purchaseOrderNumber}\n`;
      materials.forEach((material, index) => {
        message += formatMaterialLine(material, index, false) + '\n';
      });
      message += `Total: KES ${totalCost.toLocaleString()}`;
      if (deliveryDateStr) {
        message += `\nDelivery: ${deliveryDateStr}`;
      }
      message += `\nReply: ACCEPT/REJECT or 1/2\nDetails: ${shortLink || 'Contact us'}`;
    }

    return message;
  }
  
  // Strategy 2: 3-4 materials - Show abbreviated list without costs (single message)
  if (materialCount <= 4) {
    let message = `New PO: ${purchaseOrderNumber}\nMaterials:\n`;
    
    materials.forEach((material, index) => {
      message += `â€¢ ${formatMaterialLine(material, index, false).substring(3)}\n`; // Remove "1. " prefix, use bullet
    });
    
    message += `Total: KES ${totalCost.toLocaleString()}`;
    
    if (deliveryDateStr) {
      message += `\nDelivery: ${deliveryDateStr}`;
    }
    
    message += `\nReply: ACCEPT/REJECT or 1/2\nDetails: ${shortLink || 'Contact us'}`;

    // If still too long, truncate material names
    if (message.length > 160) {
      const maxNameLength = 10;
      message = message.replace(/â€¢\s+([^:]+):/g, (match, name) => {
        const truncated = truncateName(name, maxNameLength);
        return match.replace(name, truncated);
      });
    }

    // Last resort: Remove delivery date
    if (message.length > 160 && deliveryDateStr) {
      message = message.replace(`\nDelivery: ${deliveryDateStr}`, '');
    }

    return message;
  }

  // Strategy 3: 5+ materials - Use multi-part SMS if enabled
  if (enableMultiPart) {
    const messages = [];
    
    // Part 1: Summary with instructions
    let summaryMessage = `PO-${purchaseOrderNumber}: ${materialCount} materials\nTotal: KES ${totalCost.toLocaleString()}\nDelivery: ${deliveryDateStr || 'TBD'}\nSee next ${Math.ceil(materialCount / 4)} message(s) for details.\nReply: ACCEPT ALL or 1,3,5 REJECT 2,4 or 1/2`;
    
    // Apply personalization to summary message if enabled
    if (enablePersonalization && context) {
      const { personalizeMessage } = await import('./sms-personalization.js');
      summaryMessage = personalizeMessage(summaryMessage, context, language, {
        includeGreeting: true,
        includeRelationship: context.totalOrders > 3,
        includeProject: !!projectId
      });
    }
    
    messages.push(summaryMessage);

    // Part 2-N: Material details (4 materials per message)
    const materialsPerMessage = 4;
    for (let i = 0; i < materials.length; i += materialsPerMessage) {
      const materialBatch = materials.slice(i, i + materialsPerMessage);
      const partNumber = Math.floor(i / materialsPerMessage) + 2;
      const totalParts = Math.ceil(materials.length / materialsPerMessage) + 1;
      
      let materialMessage = `PO-${purchaseOrderNumber} Materials (${partNumber}/${totalParts}):\n`;
      
      materialBatch.forEach((material, batchIndex) => {
        const globalIndex = i + batchIndex + 1;
        const name = truncateName(material.materialName || material.name || `Material ${globalIndex}`, 20);
        const qty = material.quantity || material.quantityNeeded || 0;
        const unit = material.unit || '';
        const cost = material.unitCost ? ` @ KES ${material.unitCost.toLocaleString()}` : '';
        materialMessage += `${globalIndex}. ${name}: ${qty} ${unit}${cost}\n`;
      });

      materialMessage += `\nReply: ACCEPT ALL or 1,3,5 REJECT 2,4 or 1/2`;

      // Ensure message fits in 160 chars
      if (materialMessage.length > 160) {
        // Remove costs if present
        materialMessage = `PO-${purchaseOrderNumber} Materials (${partNumber}/${totalParts}):\n`;
        materialBatch.forEach((material, batchIndex) => {
          const globalIndex = i + batchIndex + 1;
          const name = truncateName(material.materialName || material.name || `Material ${globalIndex}`, 18);
          const qty = material.quantity || material.quantityNeeded || 0;
          const unit = material.unit || '';
          materialMessage += `${globalIndex}. ${name}: ${qty} ${unit}\n`;
        });
        materialMessage += `\nReply: ACCEPT ALL or 1,3,5 REJECT 2,4 or 1/2`;
      }

      messages.push(materialMessage);
    }

    // Apply personalization to first message if enabled (already done above for summary)
    // Additional messages don't need personalization to keep them concise

    return messages;
  } else {
    // Fallback to old single-message format for 5+ materials (if multi-part disabled)
    const materialsToShow = Math.min(3, materialCount);
    const materialNames = materials.slice(0, materialsToShow).map(m => 
      truncateName(m.materialName || m.name || 'Material', 15)
    ).join(', ');
    
    const remainingCount = materialCount - materialsToShow;
    const moreText = remainingCount > 0 ? ` +${remainingCount} more` : '';
    
    let message = `New PO: ${purchaseOrderNumber}\n${materialCount} materials:\n${materialNames}${moreText}\nTotal: KES ${totalCost.toLocaleString()}`;
    
    if (deliveryDateStr) {
      message += `\nDelivery: ${deliveryDateStr}`;
    }
    
    message += `\nReply: ACCEPT/REJECT or 1/2\nFull list: ${shortLink || 'Contact us'}`;

    // Apply personalization if enabled
    if (enablePersonalization && context) {
      const { personalizeMessage } = await import('./sms-personalization.js');
      return personalizeMessage(message, context, language, {
        includeGreeting: true,
        includeRelationship: context.totalOrders > 3,
        includeProject: !!projectId
      });
    }

    return message;
  }
}

/**
 * Generate SMS reminder message (enhanced with language support and personalization)
 * @param {Object} options - Reminder details
 * @param {string} options.purchaseOrderNumber - PO number
 * @param {string} options.materialName - Material name
 * @param {number} options.quantity - Quantity
 * @param {string} options.unit - Unit of measurement
 * @param {number} options.totalCost - Total cost
 * @param {string} options.shortLink - Short URL for response (optional)
 * @param {string} options.reminderType - Reminder type ('standard', 'urgent', 'final')
 * @param {number} options.daysSinceSent - Days since order was sent
 * @param {string} options.contactPhone - Contact phone for questions (optional)
 * @param {string} options.language - Language code ('en' or 'sw'), defaults to 'en'
 * @param {Object} options.supplier - Supplier object (for auto language detection)
 * @param {string} options.projectId - Project ID for context (optional)
 * @returns {Promise<string>} Formatted reminder SMS
 */
export async function generateReminderSMS({ purchaseOrderNumber, materialName, quantity, unit, totalCost, shortLink = null, reminderType = 'standard', daysSinceSent = 0, contactPhone = null, language = null, supplier = null, projectId = null }) {
  // Auto-detect language from supplier if not provided
  if (!language && supplier) {
    language = getSupplierLanguage(supplier);
  }
  
  language = language || 'en';
  
  // Use Swahili template if requested
  if (language === 'sw') {
    return swahiliTemplates.generateReminderSMSSwahili({
      purchaseOrderNumber,
      contactPhone: contactPhone || 'us'
    });
  }
  
  // Default English implementation with enhanced details
  const urgencyText = reminderType === 'urgent' ? 'URGENT: ' : 
                     reminderType === 'final' ? 'FINAL REMINDER: ' : '';
  
  let message = `${urgencyText}Reminder: ${purchaseOrderNumber}`;
  
  if (materialName) {
    const materialText = `${quantity} ${unit} ${materialName}`;
    const truncatedMaterial = materialText.length > 50 ? materialText.substring(0, 47) + '...' : materialText;
    message += `\nMaterial: ${truncatedMaterial}`;
  }
  
  if (totalCost > 0) {
    message += `\nTotal: KES ${totalCost.toLocaleString()}`;
  }
  
  if (daysSinceSent > 0) {
    message += `\nSent ${daysSinceSent} day${daysSinceSent > 1 ? 's' : ''} ago`;
  }
  
  message += '\nPlease respond: ACCEPT/REJECT or 1/2';
  
  if (shortLink) {
    message += `\nDetails: ${shortLink}`;
  } else if (contactPhone) {
    message += `\nContact: ${contactPhone}`;
  }
  
  return message;
}

/**
 * Generate SMS confirmation message
 * @param {Object} options - Confirmation details
 * @param {string} options.purchaseOrderNumber - PO number (already includes "PO-" prefix, e.g., "PO-20260104-003")
 * @param {string} options.action - Action taken (accept/reject)
 * @param {Date} options.deliveryDate - Expected delivery date (optional)
 * @param {string} options.language - Language code ('en' or 'sw'), defaults to 'en'
 * @param {Object} options.supplier - Supplier object (for auto language detection)
 * @returns {string} Formatted confirmation SMS
 */
export function generateConfirmationSMS({ purchaseOrderNumber, action, deliveryDate, language = null, supplier = null }) {
  // Auto-detect language from supplier if not provided
  if (!language && supplier) {
    language = getSupplierLanguage(supplier);
  }
  
  // Default to English if not specified
  language = language || 'en';
  
  // Use Swahili template if requested
  if (language === 'sw') {
    return swahiliTemplates.generateConfirmationSMSSwahili({
      purchaseOrderNumber,
      action,
      deliveryDate
    });
  }
  
  // Default English implementation
  const actionText = action === 'accept' ? 'ACCEPTED' : action === 'reject' ? 'REJECTED' : 'UPDATED';
  
  // purchaseOrderNumber already includes "PO-" prefix, so don't add it again
  // Format: "PO-20260104-003" (not "20260104-003")
  let message = `Thank you! ${purchaseOrderNumber} ${actionText}.`;
  
  if (action === 'accept' && deliveryDate) {
    const dateStr = new Date(deliveryDate).toLocaleDateString('en-KE', {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
    message += ` Delivery expected: ${dateStr}.`;
  }
  
  message += ' We\'ll contact you soon.';
  return message;
}

/**
 * Validate phone number format
 * @param {string} phone - Phone number to validate
 * @returns {boolean} True if valid format
 */
export function validatePhoneNumber(phone) {
  if (!phone || typeof phone !== 'string') {
    return false;
  }

  // Remove spaces and dashes
  const cleaned = phone.replace(/[\s-]/g, '');
  
  // Check if starts with + and has 10-15 digits after country code
  const phoneRegex = /^\+[1-9]\d{9,14}$/;
  return phoneRegex.test(cleaned);
}

/**
 * Format phone number with country code
 * @param {string} phone - Phone number
 * @param {string} defaultCountryCode - Default country code (e.g., +254 for Kenya)
 * @returns {string} Formatted phone number
 */
export function formatPhoneNumber(phone, defaultCountryCode = '+254') {
  if (!phone) {
    return null;
  }

  // Remove all non-digit characters except +
  const cleaned = phone.replace(/[^\d+]/g, '');

  // If already has country code, return as is
  if (cleaned.startsWith('+')) {
    return cleaned;
  }

  // If starts with 0, replace with country code
  if (cleaned.startsWith('0')) {
    return defaultCountryCode + cleaned.substring(1);
  }

  // If starts with country code without +, add +
  if (cleaned.startsWith(defaultCountryCode.replace('+', ''))) {
    return '+' + cleaned;
  }

  // Otherwise, prepend country code
  return defaultCountryCode + cleaned;
}

/**
 * Generate SMS message for modification approval
 * @param {Object} options - Modification approval details
 * @param {string} options.purchaseOrderNumber - PO number
 * @param {Object} options.modifications - Modification details (unitCost, quantityOrdered, deliveryDate)
 * @param {boolean} options.autoCommit - Whether order was auto-committed
 * @param {Date} options.deliveryDate - New delivery date (optional)
 * @param {string} options.language - Language code ('en' or 'sw'), defaults to 'en'
 * @param {Object} options.supplier - Supplier object (for auto language detection)
 * @returns {string} Formatted SMS message
 */
export function generateModificationApprovalSMS({ purchaseOrderNumber, modifications, autoCommit = false, deliveryDate = null, language = null, supplier = null }) {
  // Auto-detect language from supplier if not provided
  if (!language && supplier) {
    language = getSupplierLanguage(supplier);
  }
  
  // Default to English if not specified
  language = language || 'en';
  
  // Use Swahili template if requested
  if (language === 'sw') {
    return swahiliTemplates.generateModificationApprovalSMSSwahili({
      purchaseOrderNumber,
      modifications,
      autoCommit,
      deliveryDate
    });
  }
  
  // Default English implementation
  let message = `Your modification for ${purchaseOrderNumber} has been APPROVED.`;
  
  const changes = [];
  if (modifications.unitCost !== undefined) {
    changes.push(`Price: KES ${modifications.unitCost.toLocaleString()}`);
  }
  if (modifications.quantityOrdered !== undefined) {
    changes.push(`Qty: ${modifications.quantityOrdered}`);
  }
  if (modifications.deliveryDate || deliveryDate) {
    const dateStr = new Date(modifications.deliveryDate || deliveryDate).toLocaleDateString('en-KE', {
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    });
    changes.push(`Delivery: ${dateStr}`);
  }
  
  if (changes.length > 0) {
    message += `\nNew: ${changes.join(', ')}.`;
  }
  
  if (autoCommit) {
    message += `\nOrder is now ACCEPTED. Please confirm delivery date.`;
  } else {
    message += `\nPlease confirm you can deliver by the new date.`;
  }
  
  message += `\nReply CONFIRM or contact us.`;
  
  return message;
}

/**
 * Generate SMS message for modification rejection
 * @param {Object} options - Modification rejection details
 * @param {string} options.purchaseOrderNumber - PO number
 * @param {string} options.rejectionReason - Reason for rejection
 * @param {Object} options.originalTerms - Original order terms (unitCost, quantityOrdered, deliveryDate)
 * @param {string} options.alternativeOffer - Alternative offer message (optional)
 * @param {string} options.language - Language code ('en' or 'sw'), defaults to 'en'
 * @param {Object} options.supplier - Supplier object (for auto language detection)
 * @returns {string} Formatted SMS message
 */
export function generateModificationRejectionSMS({ purchaseOrderNumber, rejectionReason, originalTerms, alternativeOffer = null, language = null, supplier = null }) {
  // Auto-detect language from supplier if not provided
  if (!language && supplier) {
    language = getSupplierLanguage(supplier);
  }
  
  // Default to English if not specified
  language = language || 'en';
  
  // Use Swahili template if requested
  if (language === 'sw') {
    return swahiliTemplates.generateModificationRejectionSMSSwahili({
      purchaseOrderNumber,
      rejectionReason,
      originalTerms,
      alternativeOffer
    });
  }
  
  // Default English implementation
  let message = `Your modification for ${purchaseOrderNumber} was NOT APPROVED.`;
  
  if (rejectionReason) {
    message += `\nReason: ${rejectionReason}.`;
  }
  
  if (originalTerms) {
    message += `\nOriginal terms:`;
    if (originalTerms.unitCost) {
      message += ` Price: KES ${originalTerms.unitCost.toLocaleString()}`;
    }
    if (originalTerms.quantityOrdered) {
      message += ` Qty: ${originalTerms.quantityOrdered}`;
    }
    if (originalTerms.deliveryDate) {
      const dateStr = new Date(originalTerms.deliveryDate).toLocaleDateString('en-KE', {
        month: 'short',
        day: 'numeric'
      });
      message += ` Delivery: ${dateStr}`;
    }
  }
  
  if (alternativeOffer) {
    message += `\nAlternative: ${alternativeOffer}`;
  } else {
    message += `\nCan you accept original terms?`;
  }
  
  message += `\nReply ACCEPT/REJECT or contact us.`;
  
  return message;
}

/**
 * Generate SMS message for delivery confirmation to supplier
 * @param {Object} options - Delivery confirmation details
 * @param {string} options.purchaseOrderNumber - PO number
 * @param {string} options.materialName - Material name
 * @param {number} options.quantityReceived - Quantity received
 * @param {string} options.unit - Unit of measurement
 * @param {Date} options.deliveryDate - Delivery date
 * @param {string} options.status - Delivery status (approved/rejected)
 * @param {string} options.language - Language code ('en' or 'sw'), defaults to 'en'
 * @param {Object} options.supplier - Supplier object (for auto language detection)
 * @returns {string} Formatted SMS message
 */
export function generateDeliveryConfirmationSMS({ purchaseOrderNumber, materialName, quantityReceived, unit, deliveryDate, status = 'approved', language = null, supplier = null }) {
  // Auto-detect language from supplier if not provided
  if (!language && supplier) {
    language = getSupplierLanguage(supplier);
  }
  
  // Default to English if not specified
  language = language || 'en';
  
  // Use Swahili template if requested
  if (language === 'sw') {
    return swahiliTemplates.generateDeliveryConfirmationSMSSwahili({
      purchaseOrderNumber,
      materialName,
      quantityReceived,
      unit,
      deliveryDate,
      status
    });
  }
  
  // Default English implementation
  let message = `Delivery confirmed: ${purchaseOrderNumber}`;
  
  if (materialName) {
    // Truncate material name if too long
    const truncatedName = materialName.length > 25 ? materialName.substring(0, 22) + '...' : materialName;
    message += `\nReceived: ${quantityReceived} ${unit} ${truncatedName}`;
  } else {
    message += `\nReceived: ${quantityReceived} ${unit}`;
  }
  
  if (deliveryDate) {
    const dateStr = new Date(deliveryDate).toLocaleDateString('en-KE', {
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    });
    message += `\nDate: ${dateStr}`;
  }
  
  message += `\nStatus: ${status.toUpperCase()}`;
  
  if (status === 'approved') {
    message += `\nNext: Please submit invoice for payment processing.`;
  } else {
    message += `\nPlease contact us for clarification.`;
  }
  
  message += `\nThank you!`;
  
  return message;
}

/**
 * Generate delivery reminder SMS
 * @param {Object} options - Delivery reminder details
 * @param {string} options.purchaseOrderNumber - PO number
 * @param {string} options.materialName - Material name
 * @param {number} options.quantity - Quantity
 * @param {string} options.unit - Unit of measurement
 * @param {Date} options.deliveryDate - Scheduled delivery date
 * @param {string} options.language - Language code ('en' or 'sw'), defaults to 'en'
 * @param {Object} options.supplier - Supplier object (for auto language detection)
 * @returns {string} Formatted reminder SMS
 */
export function generateDeliveryReminderSMS({ purchaseOrderNumber, materialName, quantity, unit, deliveryDate, language = null, supplier = null }) {
  // Auto-detect language from supplier if not provided
  if (!language && supplier) {
    language = getSupplierLanguage(supplier);
  }
  
  language = language || 'en';
  
  const dateStr = new Date(deliveryDate).toLocaleDateString(language === 'sw' ? 'sw-KE' : 'en-KE', {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  });
  
  if (language === 'sw') {
    const materialText = materialName ? `${quantity} ${unit} ${materialName}` : `${quantity} ${unit}`;
    // Truncate if too long
    const truncatedMaterial = materialText.length > 40 ? materialText.substring(0, 37) + '...' : materialText;
    return `Kikumbusho: ${purchaseOrderNumber}\nUwasilishaji umepangwa: ${dateStr}\nBidhaa: ${truncatedMaterial}\nTafadhali thibitisha unaweza kuwasilisha tarehe hii.\nJibu THIBITISHA au pendekeza tarehe nyingine.`;
  }
  
  // English
  const materialText = materialName ? `${quantity} ${unit} ${materialName}` : `${quantity} ${unit}`;
  const truncatedMaterial = materialText.length > 40 ? materialText.substring(0, 37) + '...' : materialText;
  return `Reminder: ${purchaseOrderNumber}\nDelivery scheduled: ${dateStr}\nMaterial: ${truncatedMaterial}\nPlease confirm you can deliver on this date.\nReply CONFIRM or suggest alternative date.`;
}

/**
 * Generate delivery scheduling request SMS
 * @param {Object} options - Scheduling details
 * @param {string} options.purchaseOrderNumber - PO number
 * @param {Date} options.preferredDate - Preferred delivery date
 * @param {string} options.language - Language code ('en' or 'sw'), defaults to 'en'
 * @param {Object} options.supplier - Supplier object (for auto language detection)
 * @returns {string} Formatted scheduling SMS
 */
export function generateDeliverySchedulingSMS({ purchaseOrderNumber, preferredDate, language = null, supplier = null }) {
  // Auto-detect language from supplier if not provided
  if (!language && supplier) {
    language = getSupplierLanguage(supplier);
  }
  
  language = language || 'en';
  
  const dateStr = new Date(preferredDate).toLocaleDateString(language === 'sw' ? 'sw-KE' : 'en-KE', {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  });
  
  if (language === 'sw') {
    return `Tafadhali panga uwasilishaji: ${purchaseOrderNumber}\nTarehe inayopendekezwa: ${dateStr}\nJe, unaweza kuwasilisha tarehe hii?\nJibu THIBITISHA au pendekeza tarehe nyingine.`;
  }
  
  // English
  return `Please schedule delivery: ${purchaseOrderNumber}\nPreferred date: ${dateStr}\nCan you deliver on this date?\nReply CONFIRM or suggest alternative date.`;
}

/**
 * Generate delivery delay notification SMS
 * @param {Object} options - Delay notification details
 * @param {string} options.purchaseOrderNumber - PO number
 * @param {Date} options.originalDate - Original delivery date
 * @param {Date} options.newDate - New delivery date (optional)
 * @param {string} options.reason - Reason for delay (optional)
 * @param {string} options.language - Language code ('en' or 'sw'), defaults to 'en'
 * @param {Object} options.supplier - Supplier object (for auto language detection)
 * @returns {string} Formatted delay notification SMS
 */
export function generateDeliveryDelaySMS({ purchaseOrderNumber, originalDate, newDate = null, reason = null, language = null, supplier = null }) {
  // Auto-detect language from supplier if not provided
  if (!language && supplier) {
    language = getSupplierLanguage(supplier);
  }
  
  language = language || 'en';
  
  const originalDateStr = new Date(originalDate).toLocaleDateString(language === 'sw' ? 'sw-KE' : 'en-KE', {
    month: 'short',
    day: 'numeric'
  });
  
  if (language === 'sw') {
    let message = `Ucheleweshaji: ${purchaseOrderNumber}\nTarehe ya awali: ${originalDateStr}`;
    
    if (newDate) {
      const newDateStr = new Date(newDate).toLocaleDateString('sw-KE', {
        month: 'short',
        day: 'numeric'
      });
      message += `\nTarehe mpya: ${newDateStr}`;
    }
    
    if (reason) {
      const truncatedReason = reason.length > 60 ? reason.substring(0, 57) + '...' : reason;
      message += `\nSababu: ${truncatedReason}`;
    } else {
      message += `\nTafadhali wasiliana nasi kwa maelezo zaidi.`;
    }
    
    return message;
  }
  
  // English
  let message = `Delivery delay: ${purchaseOrderNumber}\nOriginal date: ${originalDateStr}`;
  
  if (newDate) {
    const newDateStr = new Date(newDate).toLocaleDateString('en-KE', {
      month: 'short',
      day: 'numeric'
    });
    message += `\nNew date: ${newDateStr}`;
  }
  
  if (reason) {
    const truncatedReason = reason.length > 60 ? reason.substring(0, 57) + '...' : reason;
    message += `\nReason: ${truncatedReason}`;
  } else {
    message += `\nPlease contact us for more details.`;
  }
  
  return message;
}

/**
 * Generate payment status SMS
 * @param {Object} options - Payment status details
 * @param {string} options.purchaseOrderNumber - PO number
 * @param {string} options.paymentStatus - Payment status ('pending', 'processing', 'paid', 'failed')
 * @param {number} options.amount - Payment amount
 * @param {string} options.invoiceNumber - Invoice number (optional)
 * @param {Date} options.paymentDate - Payment date (optional)
 * @param {string} options.paymentMethod - Payment method (optional)
 * @param {string} options.language - Language code ('en' or 'sw'), defaults to 'en'
 * @param {Object} options.supplier - Supplier object (for auto language detection)
 * @returns {string} Formatted payment status SMS
 */
export function generatePaymentStatusSMS({ purchaseOrderNumber, paymentStatus, amount, invoiceNumber = null, paymentDate = null, paymentMethod = null, language = null, supplier = null }) {
  // Auto-detect language from supplier if not provided
  if (!language && supplier) {
    language = getSupplierLanguage(supplier);
  }
  
  language = language || 'en';
  
  if (language === 'sw') {
    let message = '';
    
    switch (paymentStatus) {
      case 'paid':
        message = `Malipo yamefanyika: ${purchaseOrderNumber}`;
        if (amount) {
          message += `\nKiasi: KES ${amount.toLocaleString()}`;
        }
        if (invoiceNumber) {
          message += `\nAnkara: ${invoiceNumber}`;
        }
        if (paymentDate) {
          const dateStr = new Date(paymentDate).toLocaleDateString('sw-KE', {
            month: 'short',
            day: 'numeric',
            year: 'numeric'
          });
          message += `\nTarehe: ${dateStr}`;
        }
        if (paymentMethod) {
          message += `\nNjia: ${paymentMethod}`;
        }
        message += `\nAsante!`;
        break;
      
      case 'processing':
        message = `Malipo yanachakata: ${purchaseOrderNumber}`;
        if (amount) {
          message += `\nKiasi: KES ${amount.toLocaleString()}`;
        }
        if (invoiceNumber) {
          message += `\nAnkara: ${invoiceNumber}`;
        }
        message += `\nTutakujulisha mara tu yamekamilika.`;
        break;
      
      case 'failed':
        message = `Malipo yameshindwa: ${purchaseOrderNumber}`;
        if (amount) {
          message += `\nKiasi: KES ${amount.toLocaleString()}`;
        }
        message += `\nTafadhali wasiliana nasi kwa msaada.`;
        break;
      
      case 'pending':
      default:
        message = `Malipo yanasubiri: ${purchaseOrderNumber}`;
        if (amount) {
          message += `\nKiasi: KES ${amount.toLocaleString()}`;
        }
        if (invoiceNumber) {
          message += `\nTafadhali wasilisha ankara: ${invoiceNumber}`;
        } else {
          message += `\nTafadhali wasilisha ankara yako.`;
        }
        break;
    }
    
    return message;
  }
  
  // English
  let message = '';
  
  switch (paymentStatus) {
    case 'paid':
      message = `Payment processed: ${purchaseOrderNumber}`;
      if (amount) {
        message += `\nAmount: KES ${amount.toLocaleString()}`;
      }
      if (invoiceNumber) {
        message += `\nInvoice: ${invoiceNumber}`;
      }
      if (paymentDate) {
        const dateStr = new Date(paymentDate).toLocaleDateString('en-KE', {
          month: 'short',
          day: 'numeric',
          year: 'numeric'
        });
        message += `\nDate: ${dateStr}`;
      }
      if (paymentMethod) {
        message += `\nMethod: ${paymentMethod}`;
      }
      message += `\nThank you!`;
      break;
    
    case 'processing':
      message = `Payment processing: ${purchaseOrderNumber}`;
      if (amount) {
        message += `\nAmount: KES ${amount.toLocaleString()}`;
      }
      if (invoiceNumber) {
        message += `\nInvoice: ${invoiceNumber}`;
      }
      message += `\nWe'll notify you once completed.`;
      break;
    
    case 'failed':
      message = `Payment failed: ${purchaseOrderNumber}`;
      if (amount) {
        message += `\nAmount: KES ${amount.toLocaleString()}`;
      }
      message += `\nPlease contact us for assistance.`;
      break;
    
    case 'pending':
    default:
      message = `Payment pending: ${purchaseOrderNumber}`;
      if (amount) {
        message += `\nAmount: KES ${amount.toLocaleString()}`;
      }
      if (invoiceNumber) {
        message += `\nPlease submit invoice: ${invoiceNumber}`;
      } else {
        message += `\nPlease submit your invoice.`;
      }
      break;
  }
  
  return message;
}

/**
 * Generate error SMS message (with language support)
 * @param {Object} options - Error details
 * @param {string} options.errorType - Type of error ('po_not_found', 'invalid_response', 'token_expired', 'already_responded', 'unknown')
 * @param {string} options.purchaseOrderNumber - PO number (optional)
 * @param {string} options.suggestion - Suggestion message (optional)
 * @param {string} options.language - Language code ('en' or 'sw'), defaults to 'en'
 * @param {Object} options.supplier - Supplier object (for auto language detection)
 * @returns {string} Formatted error SMS message
 */
export function generateErrorSMS({ errorType, purchaseOrderNumber = null, suggestion = null, language = null, supplier = null }) {
  // Auto-detect language from supplier if not provided
  if (!language && supplier) {
    language = getSupplierLanguage(supplier);
  }
  
  // Default to English if not specified
  language = language || 'en';
  
  // Use Swahili template if requested
  if (language === 'sw') {
    return swahiliTemplates.generateErrorSMSSwahili({
      errorType,
      purchaseOrderNumber,
      suggestion
    });
  }
  
  // Default English implementation
  let message = 'Sorry, there was an error.';
  
  switch (errorType) {
    case 'po_not_found':
      message = 'Sorry, we could not find your purchase order.';
      if (purchaseOrderNumber) {
        message += ` Order: ${purchaseOrderNumber}.`;
      }
      message += ' Please contact us directly.';
      break;
    
    case 'invalid_response':
      message = 'Your response was not recognized.';
      if (suggestion) {
        message += ` ${suggestion}`;
      } else {
        message += ' Please use: ACCEPT, REJECT, or MODIFY.';
      }
      break;
    
    case 'token_expired':
      message = 'Your response link has expired.';
      message += ' Please contact us for a new link.';
      break;
    
    case 'already_responded':
      message = 'You have already responded to this order.';
      message += ' If you need to make changes, please contact us.';
      break;
    
    case 'invalid_status':
      message = 'This order cannot be responded to at this time.';
      if (suggestion) {
        message += ` ${suggestion}`;
      } else {
        message += ' Please contact us for assistance.';
      }
      break;
    
    default:
      message = 'Sorry, there was a technical error.';
      message += ' Please contact us for assistance.';
  }
  
  return message;
}

/**
 * Generate retry order SMS with context
 * @param {Object} options - Retry order details
 * @param {string} options.purchaseOrderNumber - New PO number
 * @param {string} options.originalPONumber - Original rejected PO number
 * @param {string} options.rejectionReason - Original rejection reason
 * @param {Object} options.adjustments - Adjustments made (price, quantity, deliveryDate)
 * @param {string} options.language - Language code ('en' or 'sw'), defaults to 'en'
 * @param {Object} options.supplier - Supplier object (for auto language detection)
 * @returns {string} Formatted retry SMS with context
 */
export function generateRetryOrderSMS({ purchaseOrderNumber, originalPONumber, rejectionReason, adjustments, language = null, supplier = null }) {
  // Auto-detect language from supplier if not provided
  if (!language && supplier) {
    language = getSupplierLanguage(supplier);
  }
  
  language = language || 'en';
  
  if (language === 'sw') {
    let message = `PO MPYA (Rudia): ${purchaseOrderNumber}`;
    
    if (originalPONumber) {
      message += `\nYa awali: ${originalPONumber}`;
    }
    
    if (rejectionReason) {
      message += `\nSababu ya kukataa: ${rejectionReason}`;
    }
    
    if (adjustments) {
      const changes = [];
      if (adjustments.unitCost !== undefined) {
        changes.push(`Bei: KES ${adjustments.unitCost.toLocaleString()}`);
      }
      if (adjustments.quantityOrdered !== undefined) {
        changes.push(`Kiasi: ${adjustments.quantityOrdered}`);
      }
      if (adjustments.deliveryDate) {
        const dateStr = new Date(adjustments.deliveryDate).toLocaleDateString('sw-KE', {
          month: 'short',
          day: 'numeric'
        });
        changes.push(`Tarehe: ${dateStr}`);
      }
      
      if (changes.length > 0) {
        message += `\nMabadiliko: ${changes.join(', ')}`;
      }
    }
    
    message += `\nTafadhali kagua na jibu.`;
    
    return message;
  }
  
  // English
  let message = `NEW PO (Retry): ${purchaseOrderNumber}`;
  
  if (originalPONumber) {
    message += `\nOriginal: ${originalPONumber}`;
  }
  
  if (rejectionReason) {
    message += `\nRejection reason: ${rejectionReason}`;
  }
  
  if (adjustments) {
    const changes = [];
    if (adjustments.unitCost !== undefined) {
      changes.push(`Price: KES ${adjustments.unitCost.toLocaleString()}`);
    }
    if (adjustments.quantityOrdered !== undefined) {
      changes.push(`Qty: ${adjustments.quantityOrdered}`);
    }
    if (adjustments.deliveryDate) {
      const dateStr = new Date(adjustments.deliveryDate).toLocaleDateString('en-KE', {
        month: 'short',
        day: 'numeric'
      });
      changes.push(`Date: ${dateStr}`);
    }
    
    if (changes.length > 0) {
      message += `\nChanges: ${changes.join(', ')}`;
    }
  }
  
  message += `\nPlease review and respond.`;
  
  return message;
}

/**
 * Generate alternative order SMS with context
 * @param {Object} options - Alternative order details
 * @param {string} options.purchaseOrderNumber - New PO number
 * @param {string} options.originalPONumber - Original rejected PO number
 * @param {string} options.rejectionReason - Original rejection reason
 * @param {string} options.alternativeType - Type of alternative ('price', 'quantity', 'specification', 'timeline')
 * @param {string} options.language - Language code ('en' or 'sw'), defaults to 'en'
 * @param {Object} options.supplier - Supplier object (for auto language detection)
 * @returns {string} Formatted alternative order SMS with context
 */
export function generateAlternativeOrderSMS({ purchaseOrderNumber, originalPONumber, rejectionReason, alternativeType, language = null, supplier = null }) {
  // Auto-detect language from supplier if not provided
  if (!language && supplier) {
    language = getSupplierLanguage(supplier);
  }
  
  language = language || 'en';
  
  if (language === 'sw') {
    let message = `PO MPYA (Chaguo jingine): ${purchaseOrderNumber}`;
    
    if (originalPONumber) {
      message += `\nYa awali: ${originalPONumber}`;
    }
    
    if (rejectionReason) {
      message += `\nSababu ya kukataa: ${rejectionReason}`;
    }
    
    if (alternativeType) {
      const typeText = {
        'price': 'Bei tofauti',
        'quantity': 'Kiasi tofauti',
        'specification': 'Vipimo tofauti',
        'timeline': 'Muda tofauti'
      }[alternativeType] || 'Chaguo jingine';
      message += `\nAina: ${typeText}`;
    }
    
    message += `\nTafadhali kagua na jibu.`;
    
    return message;
  }
  
  // English
  let message = `NEW PO (Alternative): ${purchaseOrderNumber}`;
  
  if (originalPONumber) {
    message += `\nOriginal: ${originalPONumber}`;
  }
  
  if (rejectionReason) {
    message += `\nRejection reason: ${rejectionReason}`;
  }
  
  if (alternativeType) {
    const typeText = {
      'price': 'Different price',
      'quantity': 'Different quantity',
      'specification': 'Different specs',
      'timeline': 'Different timeline'
    }[alternativeType] || 'Alternative';
    message += `\nType: ${typeText}`;
  }
  
  message += `\nPlease review and respond.`;
  
  return message;
}

/**
 * Generate short code help SMS
 * Provides instructions on how to use short codes for responses
 * @param {Object} options - Help message options
 * @param {string} options.language - Language code ('en' or 'sw'), defaults to 'en'
 * @param {Object} options.supplier - Supplier object (for auto language detection)
 * @returns {string} Formatted help SMS
 */
export function generateShortCodeHelpSMS({ language = null, supplier = null }) {
  // Auto-detect language from supplier if not provided
  if (!language && supplier) {
    language = getSupplierLanguage(supplier);
  }
  
  language = language || 'en';
  
  if (language === 'sw') {
    return `Msaada wa Nambari Fupi:\n1 = KUBALI\n2 = KATA\n3 = BADILISHA\nKUBALI = KUBALI\nKATA = KATA\nBADILISHA = BADILISHA\nMfano: Jibu "1" au "KUBALI"`;
  }
  
  // English
  return `Short Code Help:\n1 = ACCEPT\n2 = REJECT\n3 = MODIFY\nACCEPT = ACCEPT\nREJECT = REJECT\nMODIFY = MODIFY\nExample: Reply "1" or "ACCEPT"`;
}

/**
 * Generate material verification issue SMS
 * Notifies supplier about material verification problems
 * @param {Object} options - Verification issue details
 * @param {string} options.purchaseOrderNumber - PO number
 * @param {string} options.materialName - Material name
 * @param {string} options.issueType - Type of issue ('quantity', 'quality', 'specification', 'damage', 'missing')
 * @param {string} options.issueDescription - Description of the issue
 * @param {number} options.expectedQuantity - Expected quantity
 * @param {number} options.actualQuantity - Actual quantity received (optional)
 * @param {string} options.actionRequired - Action required from supplier
 * @param {string} options.contactPhone - Contact phone for questions
 * @param {string} options.language - Language code ('en' or 'sw'), defaults to 'en'
 * @param {Object} options.supplier - Supplier object (for auto language detection)
 * @returns {string} Formatted verification issue SMS
 */
export function generateMaterialVerificationSMS({ purchaseOrderNumber, materialName, issueType, issueDescription, expectedQuantity = null, actualQuantity = null, actionRequired = null, contactPhone = null, language = null, supplier = null }) {
  // Auto-detect language from supplier if not provided
  if (!language && supplier) {
    language = getSupplierLanguage(supplier);
  }
  
  language = language || 'en';
  
  if (language === 'sw') {
    return swahiliTemplates.generateMaterialVerificationSMSSwahili({
      purchaseOrderNumber,
      materialName,
      issueType,
      issueDescription,
      expectedQuantity,
      actualQuantity,
      actionRequired,
      contactPhone
    });
  }
  
  // English
  const issueTypeLabels = {
    quantity: 'Quantity Issue',
    quality: 'Quality Issue',
    specification: 'Specification Issue',
    damage: 'Damage Issue',
    missing: 'Missing Items',
    other: 'Verification Issue'
  };
  
  let message = `Verification Issue: ${purchaseOrderNumber}\nMaterial: ${materialName}\nIssue: ${issueTypeLabels[issueType] || issueTypeLabels.other}`;
  
  if (issueDescription) {
    message += `\nDetails: ${issueDescription}`;
  }
  
  if (expectedQuantity !== null && actualQuantity !== null) {
    message += `\nExpected: ${expectedQuantity}, Received: ${actualQuantity}`;
  } else if (expectedQuantity !== null) {
    message += `\nExpected: ${expectedQuantity}`;
  }
  
  if (actionRequired) {
    message += `\nAction: ${actionRequired}`;
  } else {
    message += `\nPlease contact us to resolve this issue.`;
  }
  
  if (contactPhone) {
    message += `\nContact: ${contactPhone}`;
  }
  
  return message;
}

/**
 * Generate order cancellation SMS
 * Notifies supplier when a purchase order is cancelled
 * @param {Object} options - Cancellation details
 * @param {string} options.purchaseOrderNumber - PO number
 * @param {string} options.reason - Reason for cancellation
 * @param {string} options.language - Language code ('en' or 'sw'), defaults to 'en'
 * @param {Object} options.supplier - Supplier object (for auto language detection)
 * @returns {string} Formatted cancellation SMS
 */
export function generateOrderCancellationSMS({ purchaseOrderNumber, reason = null, language = null, supplier = null }) {
  // Auto-detect language from supplier if not provided
  if (!language && supplier) {
    language = getSupplierLanguage(supplier);
  }
  
  language = language || 'en';
  
  if (language === 'sw') {
    let message = `Agizo limefutwa: ${purchaseOrderNumber}`;
    if (reason) {
      const truncatedReason = reason.length > 60 ? reason.substring(0, 57) + '...' : reason;
      message += `\nSababu: ${truncatedReason}`;
    }
    message += `\nTunasikitika kwa usumbufu wowote.`;
    message += `\nTutawasiliana nasi kwa maagizo ya baadaye.`;
    return message;
  }
  
  // English
  let message = `Order cancelled: ${purchaseOrderNumber}`;
  if (reason) {
    const truncatedReason = reason.length > 60 ? reason.substring(0, 57) + '...' : reason;
    message += `\nReason: ${truncatedReason}`;
  }
  message += `\nWe apologize for any inconvenience.`;
  message += `\nWe'll contact you for future orders.`;
  return message;
}
